<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Bubble Shooter Controller</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }
    body {
      display: flex;
      flex-direction: column;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* Connection status bar */
    .status-bar {
      padding: 12px 16px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s, color 0.3s;
    }
    .status-bar.connecting {
      background-color: #f59e0b;
      color: #000;
    }
    .status-bar.connected {
      background-color: #22c55e;
      color: #fff;
    }
    .status-bar.disconnected {
      background-color: #ef4444;
      color: #fff;
    }
    .status-bar.error {
      background-color: #dc2626;
      color: #fff;
    }
    .status-bar.reconnecting {
      background-color: #f59e0b;
      color: #000;
    }

    /* Reconnect overlay */
    .reconnect-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .reconnect-overlay.visible {
      display: flex;
    }
    .reconnect-title {
      color: #f59e0b;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .reconnect-status {
      color: #888;
      font-size: 16px;
      margin-bottom: 30px;
    }
    .reconnect-button {
      background: linear-gradient(145deg, #4ade80, #22c55e);
      color: #000;
      border: none;
      padding: 16px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .reconnect-button:active {
      transform: scale(0.95);
    }
    .reconnect-button:disabled {
      background: #666;
      color: #999;
    }
    .reconnect-attempts {
      color: #666;
      font-size: 14px;
      margin-top: 20px;
    }

    /* Main controller area */
    .controller-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      padding-bottom: 60px;
      position: relative;
    }

    /* Aim line (from joystick to top) */
    .aim-line {
      position: absolute;
      width: 4px;
      background: linear-gradient(to top, rgba(74, 222, 128, 0.8), rgba(74, 222, 128, 0));
      transform-origin: bottom center;
      pointer-events: none;
      display: none;
      border-radius: 2px;
    }

    /* Joystick container */
    .joystick-container {
      position: relative;
      width: 180px;
      height: 180px;
    }

    /* Joystick base (outer ring) */
    .joystick-base {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Joystick knob (inner draggable circle) */
    .joystick-knob {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: linear-gradient(145deg, #4ade80, #22c55e);
      box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
      position: absolute;
      transition: transform 0.05s ease-out;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .joystick-knob::after {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
    }
    .joystick-knob.active {
      background: linear-gradient(145deg, #86efac, #4ade80);
      box-shadow: 0 4px 20px rgba(74, 222, 128, 0.6);
    }

    /* Instructions text */
    .instructions {
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      text-align: center;
      margin-bottom: 30px;
    }

    /* Angle display */
    .angle-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 48px;
      font-weight: 300;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .angle-display.visible {
      opacity: 1;
    }

    /* Game Over overlay */
    .gameover-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      padding: 20px;
    }
    .gameover-overlay.visible {
      display: flex;
    }
    .gameover-title {
      color: #ef4444;
      font-size: 36px;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
    }
    .gameover-score {
      color: #fbbf24;
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 20px;
    }
    .gameover-highscore {
      color: #4ade80;
      font-size: 18px;
      margin-bottom: 30px;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
    }
    .initials-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    .initials-label {
      color: #888;
      font-size: 14px;
      margin-bottom: 15px;
    }
    .initials-input {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .initial-box {
      width: 60px;
      height: 70px;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .initial-box.selected {
      border-color: #4ade80;
      background: rgba(74, 222, 128, 0.1);
    }
    .initial-letter {
      color: #fff;
      font-size: 32px;
      font-weight: bold;
    }
    .initial-arrows {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .initial-arrow {
      width: 30px;
      height: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 5px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .initial-arrow:active {
      background: rgba(74, 222, 128, 0.5);
    }
    .countdown-timer {
      color: #f59e0b;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 20px;
    }
    .countdown-timer.urgent {
      color: #ef4444;
      animation: blink 0.5s ease-in-out infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .submit-button {
      background: linear-gradient(145deg, #4ade80, #22c55e);
      color: #000;
      border: none;
      padding: 16px 50px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .submit-button:active {
      transform: scale(0.95);
    }
    .gameover-message {
      color: #888;
      font-size: 16px;
      text-align: center;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="status-bar connecting" id="statusBar">Connecting...</div>

  <!-- Reconnect overlay -->
  <div class="reconnect-overlay" id="reconnectOverlay">
    <div class="reconnect-title" id="reconnectTitle">Disconnected</div>
    <div class="reconnect-status" id="reconnectStatus">Attempting to reconnect...</div>
    <button class="reconnect-button" id="reconnectButton">Reconnect</button>
    <div class="reconnect-attempts" id="reconnectAttempts"></div>
  </div>

  <!-- Game Over overlay -->
  <div class="gameover-overlay" id="gameoverOverlay">
    <div class="gameover-title">GAME OVER</div>
    <div class="gameover-score" id="gameoverScore">0</div>
    <div class="gameover-highscore" id="gameoverHighscore" style="display: none;">NEW HIGH SCORE!</div>

    <div class="initials-section" id="initialsSection">
      <div class="initials-label">Enter your initials:</div>
      <div class="initials-input">
        <div class="initial-box selected" data-index="0">
          <button class="initial-arrow" data-dir="up">&#9650;</button>
          <span class="initial-letter" id="initial0">A</span>
          <button class="initial-arrow" data-dir="down">&#9660;</button>
        </div>
        <div class="initial-box" data-index="1">
          <button class="initial-arrow" data-dir="up">&#9650;</button>
          <span class="initial-letter" id="initial1">A</span>
          <button class="initial-arrow" data-dir="down">&#9660;</button>
        </div>
        <div class="initial-box" data-index="2">
          <button class="initial-arrow" data-dir="up">&#9650;</button>
          <span class="initial-letter" id="initial2">A</span>
          <button class="initial-arrow" data-dir="down">&#9660;</button>
        </div>
      </div>
      <div class="countdown-timer" id="countdownTimer">20</div>
      <button class="submit-button" id="submitInitials">SAVE SCORE</button>
    </div>

    <div class="gameover-message" id="gameoverMessage"></div>
  </div>

  <div class="controller-area" id="controllerArea">
    <div class="angle-display" id="angleDisplay">90°</div>
    <div class="aim-line" id="aimLine"></div>

    <p class="instructions">Pull back to aim, release to shoot</p>

    <div class="joystick-container" id="joystickContainer">
      <div class="joystick-base">
        <div class="joystick-knob" id="joystickKnob"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // Configuration
    const IS_SSL = window.location.protocol === 'https:';
    const HOSTNAME = window.location.hostname === 'localhost'
      ? 'localhost'
      : `ws.${window.location.hostname}`;

    // In dev we talk to ws://localhost:3000, in production to wss://ws.<domain> (default 443)
    const WS_URL = IS_SSL
      ? `wss://${HOSTNAME}`
      : `ws://${HOSTNAME}:3000`;

    // Get room code from URL
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');

    // DOM elements
    const statusBar = document.getElementById('statusBar');
    const controllerArea = document.getElementById('controllerArea');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickKnob = document.getElementById('joystickKnob');
    const aimLine = document.getElementById('aimLine');
    const angleDisplay = document.getElementById('angleDisplay');
    const reconnectOverlay = document.getElementById('reconnectOverlay');
    const reconnectTitle = document.getElementById('reconnectTitle');
    const reconnectStatus = document.getElementById('reconnectStatus');
    const reconnectButton = document.getElementById('reconnectButton');
    const reconnectAttempts = document.getElementById('reconnectAttempts');

    // Game over DOM elements
    const gameoverOverlay = document.getElementById('gameoverOverlay');
    const gameoverScore = document.getElementById('gameoverScore');
    const gameoverHighscore = document.getElementById('gameoverHighscore');
    const initialsSection = document.getElementById('initialsSection');
    const countdownTimer = document.getElementById('countdownTimer');
    const submitInitialsBtn = document.getElementById('submitInitials');
    const gameoverMessage = document.getElementById('gameoverMessage');
    const initialBoxes = document.querySelectorAll('.initial-box');
    const initialLetters = [
      document.getElementById('initial0'),
      document.getElementById('initial1'),
      document.getElementById('initial2')
    ];

    // State
    let ws = null;
    let isConnected = false;
    let isDragging = false;
    let joystickCenter = { x: 0, y: 0 };
    let currentAngle = 90; // Degrees, 90 = straight up
    const maxDistance = 55; // Max drag distance from center

    // Game over state
    let isGameOver = false;
    let currentInitials = ['A', 'A', 'A'];
    let selectedInitialIndex = 0;
    let countdownInterval = null;
    let countdownSeconds = 30;

    // Reconnection state
    let reconnectAttemptCount = 0;
    let reconnectTimer = null;
    let isReconnecting = false;
    const MAX_AUTO_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_INTERVAL_MS = 2000; // 2 seconds between attempts
    const AUTO_RECONNECT_WINDOW_MS = 10000; // 10 seconds for auto reconnect

    // Initialize joystick center position
    function updateJoystickCenter() {
      const rect = joystickContainer.getBoundingClientRect();
      joystickCenter = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    // Update connection status UI
    function setStatus(status, message) {
      statusBar.className = 'status-bar ' + status;
      statusBar.textContent = message;
    }

    // Show/hide reconnect overlay
    function showReconnectOverlay(title, status, showButton = false) {
      reconnectTitle.textContent = title;
      reconnectStatus.textContent = status;
      reconnectButton.style.display = showButton ? 'block' : 'none';
      reconnectOverlay.classList.add('visible');
    }

    function hideReconnectOverlay() {
      reconnectOverlay.classList.remove('visible');
      reconnectAttemptCount = 0;
      isReconnecting = false;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
    }

    function updateReconnectAttempts() {
      if (reconnectAttemptCount > 0) {
        reconnectAttempts.textContent = `Attempt ${reconnectAttemptCount} of ${MAX_AUTO_RECONNECT_ATTEMPTS}`;
      } else {
        reconnectAttempts.textContent = '';
      }
    }

    // Connect to WebSocket server
    function connect(isReconnect = false) {
      if (!roomCode) {
        setStatus('error', 'No room code provided');
        return;
      }

      if (isReconnect) {
        setStatus('reconnecting', 'Reconnecting...');
      } else {
        setStatus('connecting', 'Connecting...');
      }

      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        if (isReconnect) {
          // Reconnect to existing room
          ws.send(JSON.stringify({
            type: 'reconnect',
            data: { roomCode, clientType: 'phone' }
          }));
        } else {
          // Join the room for first time
          ws.send(JSON.stringify({
            type: 'join_room',
            data: { roomCode }
          }));
        }
      };

      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleMessage(message);
      };

      ws.onerror = () => {
        setStatus('error', 'Connection error');
        isConnected = false;
        handleConnectionLost();
      };

      ws.onclose = () => {
        if (isConnected) {
          isConnected = false;
          handleConnectionLost();
        }
      };
    }

    // Handle connection loss and auto-reconnect
    function handleConnectionLost() {
      if (isReconnecting) return; // Already handling reconnection

      isReconnecting = true;
      reconnectAttemptCount = 0;
      showReconnectOverlay('Disconnected', 'Attempting to reconnect...');
      startAutoReconnect();
    }

    function startAutoReconnect() {
      if (reconnectAttemptCount >= MAX_AUTO_RECONNECT_ATTEMPTS) {
        // Auto-reconnect failed, show manual button
        setStatus('disconnected', 'Auto-reconnect failed');
        showReconnectOverlay(
          'Connection Lost',
          'Auto-reconnect timed out',
          true // Show manual reconnect button
        );
        reconnectAttempts.textContent = '';
        return;
      }

      reconnectAttemptCount++;
      updateReconnectAttempts();
      reconnectStatus.textContent = 'Attempting to reconnect...';

      reconnectTimer = setTimeout(() => {
        if (!isConnected) {
          connect(true); // Attempt reconnect

          // Schedule next attempt if this one fails
          reconnectTimer = setTimeout(() => {
            if (!isConnected && isReconnecting) {
              startAutoReconnect();
            }
          }, RECONNECT_INTERVAL_MS);
        }
      }, reconnectAttemptCount === 1 ? 0 : RECONNECT_INTERVAL_MS);
    }

    // Manual reconnect button handler
    function manualReconnect() {
      reconnectButton.disabled = true;
      reconnectStatus.textContent = 'Connecting...';
      reconnectAttemptCount = 0;

      connect(true);

      // Re-enable button after a short delay
      setTimeout(() => {
        reconnectButton.disabled = false;
      }, 2000);
    }

    // Handle incoming WebSocket messages
    function handleMessage(message) {
      switch (message.type) {
        case 'room_joined':
          isConnected = true;
          setStatus('connected', 'Connected');
          hideReconnectOverlay();
          break;
        case 'reconnected':
          isConnected = true;
          setStatus('connected', 'Reconnected');
          hideReconnectOverlay();
          break;
        case 'error':
          setStatus('error', message.data?.message || 'Error');
          const errorMsg = message.data?.message || '';
          if (errorMsg.includes('Room') && (errorMsg.includes('not found') || errorMsg.includes('expired'))) {
            // Room no longer exists, show error state
            showReconnectOverlay(
              'Room Expired',
              'The game session has ended',
              false
            );
            isReconnecting = false;
            // Close WebSocket
            if (ws) {
              ws.close();
              ws = null;
            }
            isConnected = false;
          }
          break;
        case 'peer_disconnected':
          setStatus('disconnected', 'Desktop disconnected');
          break;
        case 'peer_reconnected':
          setStatus('connected', 'Connected');
          break;
        case 'game_over':
          handleGameOver(message.data);
          break;
        case 'room_closed':
          handleRoomClosed();
          break;
      }
    }

    // Handle game over - show initials entry
    function handleGameOver(data) {
      isGameOver = true;
      const { score, isHighScore } = data;

      // Update score display
      gameoverScore.textContent = score.toString();

      // Show/hide high score message and initials section
      if (isHighScore) {
        gameoverHighscore.style.display = 'block';
        initialsSection.style.display = 'flex';
        gameoverMessage.textContent = '';
        startCountdown();
      } else {
        gameoverHighscore.style.display = 'none';
        initialsSection.style.display = 'none';
        gameoverMessage.textContent = 'Thanks for playing!';
        // Auto-submit after 3 seconds if not a high score
        setTimeout(() => {
          if (isGameOver) {
            sendInitials(null);
          }
        }, 3000);
      }

      // Reset initials state
      currentInitials = ['A', 'A', 'A'];
      selectedInitialIndex = 0;
      updateInitialsDisplay();

      // Show overlay
      gameoverOverlay.classList.add('visible');
      controllerArea.style.display = 'none';
    }

    // Start the 20-second countdown timer
    function startCountdown() {
      countdownSeconds = 20;
      countdownTimer.textContent = countdownSeconds;
      countdownTimer.classList.remove('urgent');

      if (countdownInterval) {
        clearInterval(countdownInterval);
      }

      countdownInterval = setInterval(() => {
        countdownSeconds--;
        countdownTimer.textContent = countdownSeconds;

        if (countdownSeconds <= 5) {
          countdownTimer.classList.add('urgent');
        }

        if (countdownSeconds <= 0) {
          clearInterval(countdownInterval);
          // Auto-submit with current initials
          submitInitials();
        }
      }, 1000);
    }

    // Update the initials display
    function updateInitialsDisplay() {
      for (let i = 0; i < 3; i++) {
        initialLetters[i].textContent = currentInitials[i];
        initialBoxes[i].classList.toggle('selected', i === selectedInitialIndex);
      }
    }

    // Change a letter up or down
    function changeLetter(index, direction) {
      let charCode = currentInitials[index].charCodeAt(0);
      if (direction === 'up') {
        // Up arrow should go to the previous letter (toward A)
        charCode = charCode <= 65 ? 90 : charCode - 1; // A -> Z, else prev
      } else {
        // Down arrow should go to the next letter (toward Z)
        charCode = charCode >= 90 ? 65 : charCode + 1; // Z -> A, else next
      }
      currentInitials[index] = String.fromCharCode(charCode);
      updateInitialsDisplay();
    }

    // Submit initials to desktop
    function submitInitials() {
      if (!isGameOver) return;

      // Stop countdown
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }

      const initials = currentInitials.join('');
      sendInitials(initials);

      // Update UI
      initialsSection.style.display = 'none';
      gameoverMessage.textContent = 'Score saved! Waiting for new game...';
    }

    // Send initials to desktop
    function sendInitials(initials) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'submit_initials',
          data: { initials }
        }));
      }
    }

    // Handle room closed - show message
    function handleRoomClosed() {
      isGameOver = false;

      // Clear countdown if running
      if (countdownInterval) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }

      gameoverOverlay.classList.remove('visible');
      controllerArea.style.display = 'none';

      // Close WebSocket since room no longer exists
      if (ws) {
        ws.close();
        ws = null;
      }
      isConnected = false;

      // Show room expired overlay
      showReconnectOverlay(
        'Game Ended',
        'Scan the QR code to play again',
        false
      );
    }

    // Send shoot command to desktop
    function sendShoot(angle) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'shoot',
          data: { angle }
        }));
      }
    }

    // Send aim update to desktop (for trajectory preview)
    function sendAim(angle) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'aim',
          data: { angle }
        }));
      }
    }

    // Calculate angle from joystick position (inverted controls)
    function calculateAngle(dx, dy) {
      // Inverted: pull back to aim forward (like Angry Birds)
      // Negate dx and dy so pulling down-left shoots up-right
      let angle = Math.atan2(dy, -dx) * (180 / Math.PI);
      // Normalize to 0-180 range (we only shoot upward)
      if (angle < 0) angle += 360;
      // Clamp to valid shooting angles (10-170 degrees)
      return Math.max(10, Math.min(170, angle));
    }

    // Update joystick knob position
    function updateJoystickPosition(clientX, clientY) {
      const dx = clientX - joystickCenter.x;
      const dy = clientY - joystickCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Clamp to max distance
      let clampedX = dx;
      let clampedY = dy;

      if (distance > maxDistance) {
        const scale = maxDistance / distance;
        clampedX = dx * scale;
        clampedY = dy * scale;
      }

      // Update knob position
      joystickKnob.style.transform = `translate(${clampedX}px, ${clampedY}px)`;

      // Calculate and display angle (only if there's significant movement)
      if (distance > 10) {
        currentAngle = calculateAngle(clampedX, clampedY);
        angleDisplay.textContent = `${Math.round(currentAngle)}°`;

        // Update aim line
        updateAimLine(clampedX, clampedY, distance);

        // Send aim update to game for trajectory preview
        sendAim(currentAngle);
      }
    }

    // Update the aim line visual
    function updateAimLine(dx, dy, distance) {
      if (distance < 10) {
        aimLine.style.display = 'none';
        return;
      }

      const containerRect = joystickContainer.getBoundingClientRect();
      const areaRect = controllerArea.getBoundingClientRect();

      // Position aim line starting from joystick center
      const startX = containerRect.left + containerRect.width / 2 - areaRect.left;
      const startY = containerRect.top + containerRect.height / 2 - areaRect.top;

      // Calculate line length based on drag distance
      const lineLength = Math.min(200, distance * 3);

      // Calculate rotation angle (CSS rotation is clockwise from top)
      // Inverted: aim line points opposite to drag direction
      const rotation = Math.atan2(-dx, dy) * (180 / Math.PI);

      aimLine.style.display = 'block';
      aimLine.style.left = `${startX - 2}px`;
      aimLine.style.bottom = `${areaRect.height - startY}px`;
      aimLine.style.height = `${lineLength}px`;
      aimLine.style.transform = `rotate(${rotation}deg)`;
    }

    // Reset joystick to center
    function resetJoystick() {
      joystickKnob.style.transform = 'translate(0, 0)';
      joystickKnob.classList.remove('active');
      aimLine.style.display = 'none';
      angleDisplay.classList.remove('visible');
    }

    // Touch/mouse event handlers
    function handleStart(e) {
      e.preventDefault();
      isDragging = true;
      joystickKnob.classList.add('active');
      angleDisplay.classList.add('visible');
      updateJoystickCenter();

      const point = e.touches ? e.touches[0] : e;
      updateJoystickPosition(point.clientX, point.clientY);
    }

    function handleMove(e) {
      if (!isDragging) return;
      e.preventDefault();

      const point = e.touches ? e.touches[0] : e;
      updateJoystickPosition(point.clientX, point.clientY);
    }

    function handleEnd(e) {
      if (!isDragging) return;
      e.preventDefault();

      isDragging = false;

      // Send shoot command if we had a valid drag
      const rect = joystickContainer.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Get last known position from the knob's transform
      const transform = joystickKnob.style.transform;
      const match = transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);

      if (match) {
        const dx = parseFloat(match[1]);
        const dy = parseFloat(match[2]);
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only shoot if drag was significant
        if (distance > 15) {
          sendShoot(currentAngle);
        }
      }

      resetJoystick();
    }

    // Prevent default touch behaviors on the whole document
    document.addEventListener('touchmove', (e) => {
      if (isDragging) {
        e.preventDefault();
      }
    }, { passive: false });

    // Prevent context menu on long press
    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Attach event listeners to joystick
    joystickContainer.addEventListener('touchstart', handleStart, { passive: false });
    joystickContainer.addEventListener('mousedown', handleStart);

    document.addEventListener('touchmove', handleMove, { passive: false });
    document.addEventListener('mousemove', handleMove);

    document.addEventListener('touchend', handleEnd);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchcancel', handleEnd);

    // Handle window resize
    window.addEventListener('resize', updateJoystickCenter);
    window.addEventListener('orientationchange', () => {
      setTimeout(updateJoystickCenter, 100);
    });

    // Tap status bar to reconnect when disconnected
    statusBar.addEventListener('click', () => {
      if (!isConnected && ws?.readyState !== WebSocket.CONNECTING) {
        connect(true);
      }
    });

    // Manual reconnect button
    reconnectButton.addEventListener('click', manualReconnect);

    // Initials input - arrow buttons
    document.querySelectorAll('.initial-arrow').forEach(arrow => {
      arrow.addEventListener('click', (e) => {
        e.stopPropagation();
        const box = arrow.closest('.initial-box');
        const index = parseInt(box.dataset.index);
        const direction = arrow.dataset.dir;
        selectedInitialIndex = index;
        changeLetter(index, direction);
      });

      // Touch support
      arrow.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const box = arrow.closest('.initial-box');
        const index = parseInt(box.dataset.index);
        const direction = arrow.dataset.dir;
        selectedInitialIndex = index;
        changeLetter(index, direction);
      });
    });

    // Initials input - tap box to select
    initialBoxes.forEach((box, index) => {
      box.addEventListener('click', () => {
        selectedInitialIndex = index;
        updateInitialsDisplay();
      });
    });

    // Submit initials button
    submitInitialsBtn.addEventListener('click', submitInitials);

    // Initialize
    updateJoystickCenter();
    connect();
  </script>
</body>
</html>
