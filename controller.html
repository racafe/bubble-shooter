<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Bubble Shooter Controller</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }
    body {
      display: flex;
      flex-direction: column;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* Connection status bar */
    .status-bar {
      padding: 12px 16px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      transition: background-color 0.3s, color 0.3s;
    }
    .status-bar.connecting {
      background-color: #f59e0b;
      color: #000;
    }
    .status-bar.connected {
      background-color: #22c55e;
      color: #fff;
    }
    .status-bar.disconnected {
      background-color: #ef4444;
      color: #fff;
    }
    .status-bar.error {
      background-color: #dc2626;
      color: #fff;
    }
    .status-bar.reconnecting {
      background-color: #f59e0b;
      color: #000;
    }

    /* Reconnect overlay */
    .reconnect-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .reconnect-overlay.visible {
      display: flex;
    }
    .reconnect-title {
      color: #f59e0b;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .reconnect-status {
      color: #888;
      font-size: 16px;
      margin-bottom: 30px;
    }
    .reconnect-button {
      background: linear-gradient(145deg, #4ade80, #22c55e);
      color: #000;
      border: none;
      padding: 16px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 30px;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .reconnect-button:active {
      transform: scale(0.95);
    }
    .reconnect-button:disabled {
      background: #666;
      color: #999;
    }
    .reconnect-attempts {
      color: #666;
      font-size: 14px;
      margin-top: 20px;
    }

    /* Main controller area */
    .controller-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: center;
      padding-bottom: 60px;
      position: relative;
    }

    /* Aim line (from joystick to top) */
    .aim-line {
      position: absolute;
      width: 4px;
      background: linear-gradient(to top, rgba(74, 222, 128, 0.8), rgba(74, 222, 128, 0));
      transform-origin: bottom center;
      pointer-events: none;
      display: none;
      border-radius: 2px;
    }

    /* Joystick container */
    .joystick-container {
      position: relative;
      width: 180px;
      height: 180px;
    }

    /* Joystick base (outer ring) */
    .joystick-base {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid rgba(255, 255, 255, 0.3);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Joystick knob (inner draggable circle) */
    .joystick-knob {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: linear-gradient(145deg, #4ade80, #22c55e);
      box-shadow: 0 4px 15px rgba(74, 222, 128, 0.4);
      position: absolute;
      transition: transform 0.05s ease-out;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .joystick-knob::after {
      content: '';
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
    }
    .joystick-knob.active {
      background: linear-gradient(145deg, #86efac, #4ade80);
      box-shadow: 0 4px 20px rgba(74, 222, 128, 0.6);
    }

    /* Instructions text */
    .instructions {
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      text-align: center;
      margin-bottom: 30px;
    }

    /* Angle display */
    .angle-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 48px;
      font-weight: 300;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .angle-display.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="status-bar connecting" id="statusBar">Connecting...</div>

  <!-- Reconnect overlay -->
  <div class="reconnect-overlay" id="reconnectOverlay">
    <div class="reconnect-title" id="reconnectTitle">Disconnected</div>
    <div class="reconnect-status" id="reconnectStatus">Attempting to reconnect...</div>
    <button class="reconnect-button" id="reconnectButton">Reconnect</button>
    <div class="reconnect-attempts" id="reconnectAttempts"></div>
  </div>

  <div class="controller-area" id="controllerArea">
    <div class="angle-display" id="angleDisplay">90°</div>
    <div class="aim-line" id="aimLine"></div>

    <p class="instructions">Drag to aim, release to shoot</p>

    <div class="joystick-container" id="joystickContainer">
      <div class="joystick-base">
        <div class="joystick-knob" id="joystickKnob"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // Configuration
    const WS_URL = `ws://${window.location.hostname}:3000`;

    // Get room code from URL
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('room');

    // DOM elements
    const statusBar = document.getElementById('statusBar');
    const controllerArea = document.getElementById('controllerArea');
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickKnob = document.getElementById('joystickKnob');
    const aimLine = document.getElementById('aimLine');
    const angleDisplay = document.getElementById('angleDisplay');
    const reconnectOverlay = document.getElementById('reconnectOverlay');
    const reconnectTitle = document.getElementById('reconnectTitle');
    const reconnectStatus = document.getElementById('reconnectStatus');
    const reconnectButton = document.getElementById('reconnectButton');
    const reconnectAttempts = document.getElementById('reconnectAttempts');

    // State
    let ws = null;
    let isConnected = false;
    let isDragging = false;
    let joystickCenter = { x: 0, y: 0 };
    let currentAngle = 90; // Degrees, 90 = straight up
    const maxDistance = 55; // Max drag distance from center

    // Reconnection state
    let reconnectAttemptCount = 0;
    let reconnectTimer = null;
    let isReconnecting = false;
    const MAX_AUTO_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_INTERVAL_MS = 2000; // 2 seconds between attempts
    const AUTO_RECONNECT_WINDOW_MS = 10000; // 10 seconds for auto reconnect

    // Initialize joystick center position
    function updateJoystickCenter() {
      const rect = joystickContainer.getBoundingClientRect();
      joystickCenter = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    // Update connection status UI
    function setStatus(status, message) {
      statusBar.className = 'status-bar ' + status;
      statusBar.textContent = message;
    }

    // Show/hide reconnect overlay
    function showReconnectOverlay(title, status, showButton = false) {
      reconnectTitle.textContent = title;
      reconnectStatus.textContent = status;
      reconnectButton.style.display = showButton ? 'block' : 'none';
      reconnectOverlay.classList.add('visible');
    }

    function hideReconnectOverlay() {
      reconnectOverlay.classList.remove('visible');
      reconnectAttemptCount = 0;
      isReconnecting = false;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
    }

    function updateReconnectAttempts() {
      if (reconnectAttemptCount > 0) {
        reconnectAttempts.textContent = `Attempt ${reconnectAttemptCount} of ${MAX_AUTO_RECONNECT_ATTEMPTS}`;
      } else {
        reconnectAttempts.textContent = '';
      }
    }

    // Connect to WebSocket server
    function connect(isReconnect = false) {
      if (!roomCode) {
        setStatus('error', 'No room code provided');
        return;
      }

      if (isReconnect) {
        setStatus('reconnecting', 'Reconnecting...');
      } else {
        setStatus('connecting', 'Connecting...');
      }

      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        if (isReconnect) {
          // Reconnect to existing room
          ws.send(JSON.stringify({
            type: 'reconnect',
            data: { roomCode, clientType: 'phone' }
          }));
        } else {
          // Join the room for first time
          ws.send(JSON.stringify({
            type: 'join_room',
            data: { roomCode }
          }));
        }
      };

      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleMessage(message);
      };

      ws.onerror = () => {
        setStatus('error', 'Connection error');
        isConnected = false;
        handleConnectionLost();
      };

      ws.onclose = () => {
        if (isConnected) {
          isConnected = false;
          handleConnectionLost();
        }
      };
    }

    // Handle connection loss and auto-reconnect
    function handleConnectionLost() {
      if (isReconnecting) return; // Already handling reconnection

      isReconnecting = true;
      reconnectAttemptCount = 0;
      showReconnectOverlay('Disconnected', 'Attempting to reconnect...');
      startAutoReconnect();
    }

    function startAutoReconnect() {
      if (reconnectAttemptCount >= MAX_AUTO_RECONNECT_ATTEMPTS) {
        // Auto-reconnect failed, show manual button
        setStatus('disconnected', 'Auto-reconnect failed');
        showReconnectOverlay(
          'Connection Lost',
          'Auto-reconnect timed out',
          true // Show manual reconnect button
        );
        reconnectAttempts.textContent = '';
        return;
      }

      reconnectAttemptCount++;
      updateReconnectAttempts();
      reconnectStatus.textContent = 'Attempting to reconnect...';

      reconnectTimer = setTimeout(() => {
        if (!isConnected) {
          connect(true); // Attempt reconnect

          // Schedule next attempt if this one fails
          reconnectTimer = setTimeout(() => {
            if (!isConnected && isReconnecting) {
              startAutoReconnect();
            }
          }, RECONNECT_INTERVAL_MS);
        }
      }, reconnectAttemptCount === 1 ? 0 : RECONNECT_INTERVAL_MS);
    }

    // Manual reconnect button handler
    function manualReconnect() {
      reconnectButton.disabled = true;
      reconnectStatus.textContent = 'Connecting...';
      reconnectAttemptCount = 0;

      connect(true);

      // Re-enable button after a short delay
      setTimeout(() => {
        reconnectButton.disabled = false;
      }, 2000);
    }

    // Handle incoming WebSocket messages
    function handleMessage(message) {
      switch (message.type) {
        case 'room_joined':
          isConnected = true;
          setStatus('connected', 'Connected');
          hideReconnectOverlay();
          break;
        case 'reconnected':
          isConnected = true;
          setStatus('connected', 'Reconnected');
          hideReconnectOverlay();
          break;
        case 'error':
          setStatus('error', message.data?.message || 'Error');
          if (message.data?.message === 'Room expired or not found') {
            // Room no longer exists, show error state
            showReconnectOverlay(
              'Room Expired',
              'The game session has ended',
              false
            );
            isReconnecting = false;
          }
          break;
        case 'peer_disconnected':
          setStatus('disconnected', 'Desktop disconnected');
          break;
        case 'peer_reconnected':
          setStatus('connected', 'Connected');
          break;
      }
    }

    // Send shoot command to desktop
    function sendShoot(angle) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'shoot',
          data: { angle }
        }));
      }
    }

    // Send aim update to desktop (for trajectory preview)
    function sendAim(angle) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'aim',
          data: { angle }
        }));
      }
    }

    // Calculate angle from joystick position
    function calculateAngle(dx, dy) {
      // Convert to angle (0 = right, 90 = up, 180 = left)
      let angle = Math.atan2(-dy, dx) * (180 / Math.PI);
      // Normalize to 0-180 range (we only shoot upward)
      if (angle < 0) angle += 360;
      // Clamp to valid shooting angles (10-170 degrees)
      return Math.max(10, Math.min(170, angle));
    }

    // Update joystick knob position
    function updateJoystickPosition(clientX, clientY) {
      const dx = clientX - joystickCenter.x;
      const dy = clientY - joystickCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Clamp to max distance
      let clampedX = dx;
      let clampedY = dy;

      if (distance > maxDistance) {
        const scale = maxDistance / distance;
        clampedX = dx * scale;
        clampedY = dy * scale;
      }

      // Update knob position
      joystickKnob.style.transform = `translate(${clampedX}px, ${clampedY}px)`;

      // Calculate and display angle (only if there's significant movement)
      if (distance > 10) {
        currentAngle = calculateAngle(clampedX, clampedY);
        angleDisplay.textContent = `${Math.round(currentAngle)}°`;

        // Update aim line
        updateAimLine(clampedX, clampedY, distance);

        // Send aim update to game for trajectory preview
        sendAim(currentAngle);
      }
    }

    // Update the aim line visual
    function updateAimLine(dx, dy, distance) {
      if (distance < 10) {
        aimLine.style.display = 'none';
        return;
      }

      const containerRect = joystickContainer.getBoundingClientRect();
      const areaRect = controllerArea.getBoundingClientRect();

      // Position aim line starting from joystick center
      const startX = containerRect.left + containerRect.width / 2 - areaRect.left;
      const startY = containerRect.top + containerRect.height / 2 - areaRect.top;

      // Calculate line length based on drag distance
      const lineLength = Math.min(200, distance * 3);

      // Calculate rotation angle (CSS rotation is clockwise from top)
      const rotation = Math.atan2(dx, -dy) * (180 / Math.PI);

      aimLine.style.display = 'block';
      aimLine.style.left = `${startX - 2}px`;
      aimLine.style.bottom = `${areaRect.height - startY}px`;
      aimLine.style.height = `${lineLength}px`;
      aimLine.style.transform = `rotate(${rotation}deg)`;
    }

    // Reset joystick to center
    function resetJoystick() {
      joystickKnob.style.transform = 'translate(0, 0)';
      joystickKnob.classList.remove('active');
      aimLine.style.display = 'none';
      angleDisplay.classList.remove('visible');
    }

    // Touch/mouse event handlers
    function handleStart(e) {
      e.preventDefault();
      isDragging = true;
      joystickKnob.classList.add('active');
      angleDisplay.classList.add('visible');
      updateJoystickCenter();

      const point = e.touches ? e.touches[0] : e;
      updateJoystickPosition(point.clientX, point.clientY);
    }

    function handleMove(e) {
      if (!isDragging) return;
      e.preventDefault();

      const point = e.touches ? e.touches[0] : e;
      updateJoystickPosition(point.clientX, point.clientY);
    }

    function handleEnd(e) {
      if (!isDragging) return;
      e.preventDefault();

      isDragging = false;

      // Send shoot command if we had a valid drag
      const rect = joystickContainer.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      // Get last known position from the knob's transform
      const transform = joystickKnob.style.transform;
      const match = transform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);

      if (match) {
        const dx = parseFloat(match[1]);
        const dy = parseFloat(match[2]);
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Only shoot if drag was significant
        if (distance > 15) {
          sendShoot(currentAngle);
        }
      }

      resetJoystick();
    }

    // Prevent default touch behaviors on the whole document
    document.addEventListener('touchmove', (e) => {
      if (isDragging) {
        e.preventDefault();
      }
    }, { passive: false });

    // Prevent context menu on long press
    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Attach event listeners to joystick
    joystickContainer.addEventListener('touchstart', handleStart, { passive: false });
    joystickContainer.addEventListener('mousedown', handleStart);

    document.addEventListener('touchmove', handleMove, { passive: false });
    document.addEventListener('mousemove', handleMove);

    document.addEventListener('touchend', handleEnd);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchcancel', handleEnd);

    // Handle window resize
    window.addEventListener('resize', updateJoystickCenter);
    window.addEventListener('orientationchange', () => {
      setTimeout(updateJoystickCenter, 100);
    });

    // Tap status bar to reconnect when disconnected
    statusBar.addEventListener('click', () => {
      if (!isConnected && ws?.readyState !== WebSocket.CONNECTING) {
        connect(true);
      }
    });

    // Manual reconnect button
    reconnectButton.addEventListener('click', manualReconnect);

    // Initialize
    updateJoystickCenter();
    connect();
  </script>
</body>
</html>
